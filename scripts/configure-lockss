#!/usr/bin/env bash
#---------------------------------------------------------------------------
# configure-lockss - Collect host system information needed to run LOCKSS stack(s).

# Copyright (c) 2019, Board of Trustees of Leland Stanford Jr. University
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation and/or
# other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors10.233.231.99
# may be used to endorse or promote products derived from this software without
# specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Usage: configure-lockss [-h|--help] [-s|--stacks]
#
# Revision history:
# ---------------------------------------------------------------------------

PROGNAME=${0##*/}
VERSION="1.0"

##
## Relative paths
##
_0=$(basename "${0}")
_D0=$(dirname "${0}")

##
## Load _util
##

. "${_D0}/_util"

##
## Definitions
##

# Files
SYSTEM_CONF_FILE="${CONFIG_DIR}/system.cfg"

configure_services() {
  echo ""
  echo "Configuring installed services..."
  echo ""
  USE_LOCKSS_CFG=true

  #check metadata service
  if [ "X${USE_LOCKSS_MDQ}" = X ]; then
    USE_LOCKSS_MDQ=true
  fi
  ask_for_input "Use LOCKSS Metadata Query Service?" $(to_yes_no ${USE_LOCKSS_MDQ})
  if is_yes "${ANS}"; then
    USE_LOCKSS_MDQ=true
  else
    USE_LOCKSS_MDQ=false
  fi
  #check metadata extractor service
  if [ "X${USE_LOCKSS_MDX}" = X ]; then
    USE_LOCKSS_MDX=true
  fi
  ask_for_input "Use LOCKSS Metadata Extractor Service?" $(to_yes_no ${USE_LOCKSS_MDX})
  if is_yes "${ANS}"; then
    USE_LOCKSS_MDX=true
  else
    USE_LOCKSS_MDX=false
  fi
  #check repository service
  USE_LOCKSS_REPO=true
  #check postgres service
  if [ "X${USE_LOCKSS_POSTGRES}" = X ]; then
    USE_LOCKSS_POSTGRES=true
  fi
  ask_for_input "Use LOCKSS PostgresSQL DB Service?" $(to_yes_no ${USE_LOCKSS_POSTGRES})
  if is_yes "${ANS}"; then
    USE_LOCKSS_POSTGRES=true
    LOCKSS_POSTGRES_HOST='lockss-postgres-service'
    LOCKSS_POSTGRES_PORT=5432
    LOCKSS_POSTGRES_USER="LOCKSS"
    LOCKSS_POSTGRES_SCHEMA=${LOCKSS_POSTGRES_USER}
    LOCKSS_DBNAME_PREFIX="Lockss"
  else
    USE_LOCKSS_POSTGRES=false

    if [ "X${LOCKSS_POSTGRES_HOST}" = X ]; then
      LOCKSS_POSTGRES_HOST=${LOCKSS_HOSTNAME}
    fi
    ask_for_input "Fully qualified hostname (FQDN) of PostgreSQL host" "${LOCKSS_POSTGRES_HOST}"
    LOCKSS_POSTGRES_HOST=${ANS}

    if [ "X${LOCKSS_POSTGRES_PORT}" = X ]; then
      LOCKSS_POSTGRES_PORT=5432
    fi
    ask_for_input "Port used by PostgreSQL host" "${LOCKSS_POSTGRES_PORT}"
    LOCKSS_POSTGRES_PORT=${ANS}

    if [ "X${LOCKSS_POSTGRES_USER}" = X ]; then
      LOCKSS_POSTGRES_USER="LOCKSS"
    fi
    ask_for_input "Login name for PostgreSQL service" "${LOCKSS_POSTGRES_USER}"
    LOCKSS_POSTGRES_USER=${ANS}

    if [ "X${LOCKSS_POSTGRES_SCHEMA}" = X ]; then
      LOCKSS_POSTGRES_SCHEMA="$LOCKSS_POSTGRES_USER"
    fi
    ask_for_input "Schema for PostgreSQL service" "${LOCKSS_POSTGRES_SCHEMA}"
    LOCKSS_POSTGRES_SCHEMA=${ANS}

    if [ "X${LOCKSS_DBNAME_PREFIX}" = X ]; then
      LOCKSS_DBNAME_PREFIX="Lockss"
    fi
    ask_for_input "Database name prefix for PostgreSQL service" "${LOCKSS_DBNAME_PREFIX}"
    LOCKSS_DBNAME_PREFIX=${ANS}
  fi

  ask_for_password "Password for PostgreSQL database" "${LOCKSS_DB_PASSWD}" "" "lockss-postgres-pass"
  LOCKSS_DB_PASSWD="${PASSWD_HASH}"
  if [ -n "${PASSWD_CLEAR}" ]; then
      Add_Secret lockss-postgres-pass "${PASSWD_CLEAR}"
  fi

  #check Solr service
  if [ "X${USE_LOCKSS_SOLR}" = X ]; then
    USE_LOCKSS_SOLR=true
    LOCKSS_SOLR_HOST='lockss-solr'
    LOCKSS_SOLR_PORT='8983'
    LOCKSS_SOLR_CORE_REPO="lockss-repo"
  fi
  ask_for_input "Use LOCKSS Solr Service?" $(to_yes_no ${USE_LOCKSS_SOLR})
  if is_yes "${ANS}"; then
    USE_LOCKSS_SOLR=true
    LOCKSS_SOLR_HOST='lockss-solr-service'
    LOCKSS_SOLR_PORT='8983'
    LOCKSS_SOLR_CORE_REPO="lockss-repo"
  else
    USE_LOCKSS_SOLR=false
    if [ "X${LOCKSS_SOLR_HOST}" = X ]; then
      LOCKSS_SOLR_HOST=${LOCKSS_HOSTNAME}
    fi
    ask_for_input "Fully qualified hostname (FQDN) of Solr host" "${LOCKSS_SOLR_HOST}"
    LOCKSS_SOLR_HOST=${ANS}

    if [ "X${LOCKSS_SOLR_PORT}" = X ]; then
      LOCKSS_SOLR_PORT='8983'
    fi
    ask_for_input "Port used by Solr host" "${LOCKSS_SOLR_PORT}"
    LOCKSS_SOLR_PORT=${ANS}

    if [ "X${LOCKSS_SOLR_CORE_REPO}" = X ]; then
      LOCKSS_SOLR_CORE_REPO='lockss-repo'
    fi
    ask_for_input "Solr core repo name" "${LOCKSS_SOLR_CORE_REPO}"
    LOCKSS_SOLR_CORE_REPO=${ANS}
  fi
  # Account for solr user
  if [ "X${LOCKSS_SOLR_USER}" = X ]; then
      LOCKSS_SOLR_USER=${LOCKSS_ADMIN_USER}
  fi
  ask_for_input "User name for LOCKSS SOLR access." "${LOCKSS_SOLR_USER}"
  LOCKSS_SOLR_USER=${ANS}

  ask_for_password "Password for LOCKSS SOLR access" "${LOCKSS_SOLR_PASSWD}" "" "lockss-solr-pass
"
  LOCKSS_SOLR_PASSWD="${PASSWD_HASH}"
  if [ -n "${PASSWD_CLEAR}" ]; then
      Add_Secret lockss-solr-pass "${PASSWD_CLEAR}"
  fi

  #check HDFS service
  #    if [ "X${USE_LOCKSS_HDFS}" = X ]; then
  USE_LOCKSS_HDFS=false
  #    fi
  #    ask_for_input "Use LOCKSS HDFS Service?" $(to_yes_no ${USE_LOCKSS_HDFS})
  #    if is_yes "${ANS}"; then
  #        USE_LOCKSS_HDFS=true
  #    else
  #        USE_LOCKSS_HDFS=false
  #    fi
  echo "You can use Pywb and/or Openwayback for content replay..."
  ask_for_input "Use LOCKSS PyWb Service?" $(to_yes_no ${USE_LOCKSS_PYWB})
  if is_yes "${ANS}"; then
    USE_LOCKSS_PYWB=true
  else
    USE_LOCKSS_PYWB=false
  fi
  ask_for_input "Use LOCKSS OpenWayback Service?" $(to_yes_no ${USE_LOCKSS_OPENWB})
  if is_yes "${ANS}"; then
    echo "Using LOCKSS OpenWayback Service requires the LOCKSS Repository Service to permit insecure read request."
    ask_for_input "Okay to turn off authentication for read-only requests for LOCKSS Repository Service?" $(to_yes_no ${USE_LOCKSS_OPENWB})
    if is_yes "${ANS}"; then
      USE_LOCKSS_OPENWB=true
    else
      echo "Not enabling OpenWayback Service."
      USE_LOCKSS_OPENWB=false
    fi
  else
    USE_LOCKSS_OPENWB=false
  fi
}

# write_config_file file
write_config_file() {
  cat >"${1}" <<EOF
LOCKSS_CONFIG_VERSION="${LOCKSS_CONFIG_VERSION}"
LOCKSS_USER="${LOCKSS_USER:-lockss}"
LOCKSS_HOSTNAME="${LOCKSS_HOSTNAME}"
LOCKSS_IPADDR="${LOCKSS_IPADDR}"
LOCKSS_EXTERNAL_IPADDR="${LOCKSS_EXTERNAL_IPADDR}"
LOCKSS_V3_PORT="${LOCKSS_V3_PORT}"
LOCKSS_ACCESS_SUBNET="${LOCKSS_ACCESS_SUBNET}"
LOCKSS_MAILHUB="${LOCKSS_MAILHUB}"
LOCKSS_MAILHUB_USER="${LOCKSS_MAILHUB_USER}"
LOCKSS_MAILHUB_PASSWORD="${LOCKSS_MAILHUB_PASSWORD}"
LOCKSS_EMAIL="${LOCKSS_EMAIL}"
LOCKSS_PROPS_URL="${LOCKSS_PROPS_URL}"
LOCKSS_PROPS_PROXY="${LOCKSS_PROPS_PROXY}"
LOCKSS_PROPS_SERVER_AUTHENTICATE_KEYSTORE="${LOCKSS_PROPS_SERVER_AUTHENTICATE_KEYSTORE}"
LOCKSS_PRESERVATION_GROUP="${LOCKSS_PRESERVATION_GROUP}"
LOCKSS_DATA_DIR="${LOCKSS_DATA_DIR}"
LOCKSS_REPO_HOST_DIRS="${LOCKSS_REPO_HOST_DIRS}"
LOCKSS_REPO_CONTAINER_DIRS="${LOCKSS_REPO_CONTAINER_DIRS}"
LOCKSS_LOGS_DIR="${LOCKSS_LOGS_DIR}"
LOCKSS_ADMIN_USER="${LOCKSS_ADMIN_USER}"
LOCKSS_ADMIN_PASSWD="${LOCKSS_ADMIN_PASSWD}"
LOCKSS_DB_PASSWD="${LOCKSS_DB_PASSWD}"
LOCKSS_PROXY_PORT="${LOCKSS_PROXY_PORT}"
LOCKSS_TMPDIR="${LOCKSS_TMPDIR}"
LOCKSS_SCRIPT_LOG_DIR="${LOCKSS_SCRIPT_LOG_DIR}"
LOCKSS_POSTGRES_HOST="${LOCKSS_POSTGRES_HOST}"
LOCKSS_POSTGRES_PORT="${LOCKSS_POSTGRES_PORT}"
LOCKSS_POSTGRES_USER="${LOCKSS_POSTGRES_USER}"
LOCKSS_POSTGRES_SCHEMA="${LOCKSS_POSTGRES_SCHEMA}"
LOCKSS_DBNAME_PREFIX="${LOCKSS_DBNAME_PREFIX}"
LOCKSS_SOLR_HOST="${LOCKSS_SOLR_HOST}"
LOCKSS_SOLR_PORT=${LOCKSS_SOLR_PORT}
LOCKSS_SOLR_CORE_REPO="${LOCKSS_SOLR_CORE_REPO}"
LOCKSS_SOLR_USER="${LOCKSS_SOLR_USER}"
LOCKSS_SOLR_PASSWD="${LOCKSS_SOLR_PASSWD}"
LOCKSS_CLEAR_TMPDIR="${LOCKSS_CLEAR_TMPDIR:-yes}"
LOCKSS_TIMEZONE="${LOCKSS_TIMEZONE}"
LOCKSS_CONTAINER_SUBNETS="${LOCKSS_CONTAINER_SUBNETS}"
USE_LOCKSS_CFG="${USE_LOCKSS_CFG:-true}"
USE_LOCKSS_MDQ="${USE_LOCKSS_MDQ:-true}"
USE_LOCKSS_MDX="${USE_LOCKSS_MDX:-true}"
USE_LOCKSS_POL="${USE_LOCKSS_POL:-true}"
USE_LOCKSS_REPO="${USE_LOCKSS_REPO:-true}"
USE_LOCKSS_POSTGRES="${USE_LOCKSS_POSTGRES:-true}"
USE_LOCKSS_SOLR="${USE_LOCKSS_SOLR:-true}"
USE_LOCKSS_HDFS="${USE_LOCKSS_HDFS:-false}"
USE_LOCKSS_PYWB="${USE_LOCKSS_PYWB:-true}"
USE_LOCKSS_OPENWB="${USE_LOCKSS_OPENWB:-false}"
EOF
}
# build_config_file file user
build_config_file() {
  echo "Building config file info ${1} for user ${2}..."
  CONFIG_OK=N
  until is_yes ${CONFIG_OK}; do
    if [ "X${LOCKSS_HOSTNAME}" = X ]; then
      LOCKSS_HOSTNAME=${LOCAL_HOSTNAME}
    fi
    ask_for_input "Fully qualified hostname (FQDN) of this machine" "${LOCKSS_HOSTNAME}"
    LOCKSS_HOSTNAME=${ANS}
    if [ "X${LOCKSS_IPADDR}" = X ]; then
      LOCKSS_IPADDR=${LOCAL_IPADDR}
    fi
    IP_OK=N
    until is_yes ${IP_OK}; do
      ask_for_input "IP address of this machine" ${LOCKSS_IPADDR}
      if valid_ip_address "${ANS}"; then
        LOCKSS_IPADDR="${ANS}"
        IP_OK=Y
      fi
    done
    NAT=N
    if [ "${LOCKSS_EXTERNAL_IPADDR}X" != X ]; then
      NAT=Y
    fi
    ask_for_input "Is this machine behind NAT?" ${NAT}
    if is_yes "${ANS}"; then
      EXT_OK=N
      until is_yes ${EXT_OK}; do
        ask_for_input "External IP address for NAT" ${LOCKSS_EXTERNAL_IPADDR}
        if valid_ip_address ${ANS}; then
          LOCKSS_EXTERNAL_IPADDR=${ANS}
          EXT_OK=Y
        fi
      done
    else
      unset LOCKSS_EXTERNAL_IPADDR
    fi
    if [ "X${LOCKSS_ACCESS_SUBNET}" = "X" ]; then
      LOCKSS_ACCESS_SUBNET=$(echo ${LOCKSS_IPADDR} | sed 's/\.[0-9][0-9]*$/.0\/24/')
    fi
    SUBNET_OK=N
    until is_yes ${SUBNET_OK}; do
      ask_for_input "Initial subnet(s) for admin UI access" ${LOCKSS_ACCESS_SUBNET}
      if valid_subnet "${ANS}"; then
        LOCKSS_ACCESS_SUBNET="${ANS}"
        SUBNET_OK=Y
      fi
    done
  LOCKSS_CONTAINER_SUBNET=$(ip -4 -o addr show dev cni0| awk '{split($4,a,"/");print a[1]}')
  if [ "X${LOCKSS_CONTAINER_SUBNETS}" = "X" ]; then
      LOCKSS_CONTAINER_SUBNETS=$(echo ${LOCKSS_CONTAINER_SUBNET} | sed 's/\.[0-9][0-9]*$/.0\/24/')
  else
    SUBNET_OK=N
    until is_yes ${SUBNET_OK}; do
      ask_for_input "LOCKSS subnet for container access" ${LOCKSS_CONTAINER_SUBNETS}
      if valid_subnet "${ANS}"; then
        LOCKSS_CONTAINER_SUBNETS="${ANS}"
        SUBNET_OK=Y
      fi
    done
  fi
    if [ "X${LOCKSS_V3_PORT}" = X ]; then
      LOCKSS_V3_PORT=9729
    fi
    ask_for_input "LCAP V3 protocol port" ${LOCKSS_V3_PORT}
    if [ "X${ANS}" != "X" ]; then
      LOCKSS_V3_PORT="${ANS}"
    fi
    if [ "X${LOCKSS_PROXY_PORT}" = X ]; then
      LOCKSS_PROXY_PORT=24670
    fi
    ask_for_input "PROXY port" ${LOCKSS_PROXY_PORT}
    if [ "X${ANS}" != "X" ]; then
      LOCKSS_PROXY_PORT="${ANS}"
    fi
    if [ "X${LOCKSS_UI_PORT}" = X ]; then
      LOCKSS_UI_PORT=24600
    fi
    if [ "X${LOCKSS_MAILHUB}" = X ]; then
      LOCKSS_MAILHUB=localhost
    fi
    ask_for_input "Mail relay for this machine" ${LOCKSS_MAILHUB}
    LOCKSS_MAILHUB="${ANS}"
    NEED_USER=N
    if [ "X${LOCKSS_MAILHUB_USER}" != X ]; then
      NEED_USER=Y
    fi
    ask_for_input "Does mail relay ${LOCKSS_MAILHUB} need user & password" ${NEED_USER}
    if is_yes "${ANS}"; then
      ask_for_input "User for ${LOCKSS_MAILHUB}" ${LOCKSS_MAILHUB_USER}
      LOCKSS_MAILHUB_USER="${ANS}"
      ask_for_password "Password for ${LOCKSS_MAILHUB_USER}@${LOCKSS_MAILHUB}" "" "${LOCKSS_MAILHUB_PASSWORD}" ""
      LOCKSS_MAILHUB_PASSWORD="${PASSWD_CLEAR}"
    else
      LOCKSS_MAILHUB_USER=
      LOCKSS_MAILHUB_PASSWORD=
    fi
    EMAIL_OK=N
    until is_yes ${EMAIL_OK}; do
      ask_for_input "E-mail address for administrator" ${LOCKSS_EMAIL}
      if [ "X${ANS}" != X ]; then
        LOCKSS_EMAIL="${ANS}"
        EMAIL_OK=Y
      fi
    done
    if [ "X${LOCKSS_PROPS_URL}" = X ]; then
      LOCKSS_PROPS_URL="http://props.lockss.org:8001/demo/lockss.xml"
    fi
    ask_for_input "Configuration URL" ${LOCKSS_PROPS_URL}
    LOCKSS_PROPS_URL="${ANS}"

    if echo ${LOCKSS_PROPS_URL} | egrep -is "^https:" >/dev/null; then
      if [ "X${LOCKSS_PROPS_AUTHENTICATE_SERVER}" = X ]; then
        LOCKSS_PROPS_AUTHENTICATE_SERVER="Y"
      fi
      ask_for_input "Verify configuration server authenticity?" ${LOCKSS_PROPS_AUTHENTICATE_SERVER}
      if is_yes "${ANS}"; then
        if [ "X${LOCKSS_PROPS_SERVER_AUTHENTICATE_KEYSTORE}" = X ]; then
          LOCKSS_PROPS_SERVER_AUTHENTICATE_KEYSTORE="lockss-ca"
        fi
        ask_for_input "Server certificate keystore" ${LOCKSS_PROPS_SERVER_AUTHENTICATE_KEYSTORE}
        LOCKSS_PROPS_SERVER_AUTHENTICATE_KEYSTORE="${ANS}"
      else
        unset LOCKSS_PROPS_SERVER_AUTHENTICATE_KEYSTORE
      fi
    fi

    if [ "X${LOCKSS_PROPS_PROXY}" = X ]; then
      LOCKSS_PROPS_PROXY="NONE"
    fi
    ask_for_input "Configuration proxy (host:port)" ${LOCKSS_PROPS_PROXY}
    LOCKSS_PROPS_PROXY="${ANS}"

    if [ "X${LOCKSS_PRESERVATION_GROUP}" = X ]; then
      LOCKSS_PRESERVATION_GROUP="demo"
    fi
    ask_for_input "Preservation group(s)" "${LOCKSS_PRESERVATION_GROUP}"
    LOCKSS_PRESERVATION_GROUP="${ANS}"
    DATA_PATHS_OK=N
    until is_yes ${DATA_PATHS_OK}; do
      ask_for_input "Primary content data storage directory" ${LOCKSS_DATA_DIR}
      if [ "X${ANS}" != X ]; then
        LOCKSS_DATA_DIR="${ANS}"
        DATA_PATHS_OK=Y
      fi
    done
    USE_MULTIPLE_CACHES=false
    if [ "X${LOCKSS_REPO_HOST_DIRS}" != X ]; then
     IFS=';' read -r -a prevPaths <<< "${LOCKSS_REPO_HOST_DIRS}"
     if test ${#prevPaths[*]} -gt 1; then
      USE_MULTIPLE_CACHES=true
     fi
    fi
    prevPaths[0]=${LOCKSS_DATA_DIR}
    curPaths[0]=${LOCKSS_DATA_DIR}
    repoDirs[0]="/data"
    ask_for_input "Use additional directories for content storage?" $(to_yes_no ${USE_MULTIPLE_CACHES})
    if is_yes "${ANS}"; then
      count=1
      until is_yes "${done}"; do
        ask_for_input "Enter path to additional content storage directory $count (q to quit)" ${prevPaths[count]}
        if [ "X${ANS}" = Xq ]; then
          done=Y
        elif [ -n "${ANS}" ]; then
          curPaths[count]=${ANS}
          repoDirs[count]="/data$count"
          count=$((count+1))
        fi
      done
      new_repo_vols=$( IFS=';' ; echo "${curPaths[*]}" )
      [ "$new_repo_vols" = "${LOCKSS_REPO_HOST_DIRS}" ] || echo "If you have removed any data storage directories you must run repo cache updater."
      LOCKSS_REPO_CONTAINER_DIRS=$( IFS=';' ; echo "${repoDirs[*]}" )
      LOCKSS_REPO_HOST_DIRS=${new_repo_vols}
    else
      if test ${#prevPaths[*]} -gt 1; then
        echo "Run repo cache updater."
      fi
      LOCKSS_REPO_CONTAINER_DIRS="/data"
      LOCKSS_REPO_HOST_DIRS="${LOCKSS_DATA_DIR}"
    fi
    LOG_PATHS_OK=N
    if [ -n "${LOCKSS_LOGS_DIR}" ]; then
      log_dir_default="${LOCKSS_LOGS_DIR}"
    else
      log_dir_default="${LOCKSS_DATA_DIR}"
    fi
    until is_yes ${LOG_PATHS_OK}; do
      ask_for_input "Service logs directory" ${log_dir_default}
      if [ "X${ANS}" != X ]; then
        LOCKSS_LOGS_DIR="${ANS}"
        LOG_PATHS_OK=Y
      fi
    done
    if [ "X${LOCKSS_TMPDIR}" = X ]; then
      LOCKSS_TMPDIR=${LOCKSS_DATA_DIR}
    fi
    ask_for_input "Temporary storage directory (local storage preferred)" ${LOCKSS_TMPDIR}
    LOCKSS_TMPDIR="${ANS}"
    if [ "X${LOCKSS_SCRIPT_LOG_DIR}" = X ]; then
      LOCKSS_SCRIPT_LOG_DIR="${LOCKSS_DATA_DIR}/lockss-script-logs"
    fi
    ask_for_input "Directory for storing install script logs (local storage preferred)" ${LOCKSS_SCRIPT_LOG_DIR}
    LOCKSS_SCRIPT_LOG_DIR="${ANS}"
    USER_OK=N
    until is_yes ${USER_OK}; do
      ask_for_input "User name for web UI administration" "${LOCKSS_ADMIN_USER}"
      if [ "X${ANS}" != X ]; then
        LOCKSS_ADMIN_USER="${ANS}"
        USER_OK=Y
      fi
    done
    ask_for_password "Password for web UI administration user ${LOCKSS_ADMIN_USER}" "${LOCKSS_ADMIN_PASSWD}" "" "lockss-ui-pass lockss-auth"
    LOCKSS_ADMIN_PASSWD="${PASSWD_HASH}"
    if [ -n "${PASSWD_CLEAR}" ]; then
      Add_Secret lockss-ui-pass "${PASSWD_CLEAR}"
      Add_Secret lockss-auth "${LOCKSS_ADMIN_USER}:${PASSWD_CLEAR}"
    fi

    configure_services
    TMP_CONFIG=${CONFIG_DIR}/config.tmp
    export LOCKSS_CONFIG_VERSION=2
    export LOCKSS_USER
    write_config_file ${TMP_CONFIG} ${LOCKSS_USER}
    echo
    echo "Configuration:"
    cat ${TMP_CONFIG}

    ask_for_input "OK to store this configuration" Y
    if is_yes "${ANS}"; then
      if ! cp ${TMP_CONFIG} ${1}; then
        echo "Config not installed, left in ${TMP_CONFIG}"
        exit 1
      fi
      echo "Checking content storage directory(s)"
      for dir in "${curPaths[@]}"; do
        if ! init_one_dir ${dir} $2 750; then
          err_exit"${dir} cannot be created or written by $2.  Please fix permissions."
        fi
      done
      if [ "${LOCKSS_LOGS_DIR}" != "${LOCKSS_DATA_DIR}" ]; then
        if ! init_one_dir ${LOCKSS_LOGS_DIR} $2 755; then
          err_exit "${dir} cannot be created or written by $2.  Please fix permissions."
        fi
      fi
      if [ "${LOCKSS_TMPDIR}" != "${LOCKSS_DATA_DIR}" ]; then
        if ! init_one_dir ${LOCKSS_TMPDIR} $2 750; then
          err_exit "${dir} cannot be created or written by $2.  Please fix permissions."
        fi
      fi
      if [ "${LOCKSS_SCRIPT_LOG_DIR}" != "${LOCKSS_DATA_DIR}" ]; then
        if ! init_one_dir ${LOCKSS_SCRIPT_LOG_DIR} $2 755; then
          err_exit "${dir} cannot be created or written by $2.  Please fix permissions."
        fi
      fi

      rm -f ${TMP_CONFIG}
      echo Done
      CONFIG_OK=Y
      FILT_CONFIG=$(mktemp /tmp/filtconfig.XXXXX)
      egrep -sv 'PASSW(OR)?D.*=' <${1} >>${FILT_CONFIG}
      if ! mail -s "Config for ${2}@${LOCKSS_HOSTNAME}" ${LOCKSS_EMAIL} ${LOCKSS_TEAM} <${FILT_CONFIG}; then
        echo "The attempt to mail configuration failed.  Please check your mail configuration."
        UNSENT_FILE=/tmp/unsent-lockss-config
        cp ${FILT_CONFIG} ${UNSENT_FILE}
        echo "Please also send ${UNSENT_FILE} to ${LOCKSS_TEAM}."
      fi
      rm -f ${FILT_CONFIG}

    fi
  done
}

###
# Start
###
CONFIG_USER=$(whoami)
OS_TYPE=$(uname -s)
if [ -z "${LOCKSS_TEAM}" ]; then
  LOCKSS_TEAM=lockssdiag@lockss.org
fi
umask 002
LOCKSS_USER="lockss"
LOCAL_HOSTNAME=$(hostname -f 2>/dev/null) || $(uname -n 2>/dev/null)

echo "-------------------------------------------------------------"
echo "$(${SCRIPTS_DIR}/installer-version)"
echo "-------------------------------------------------------------"
echo "$(date) Checking system state..."

# Sanity checks
if [ -z "${BYPASS_CHECK_RUNNABLE}" ]; then
  Check_Runnable
else
  echo "Bypassing Check_Runnable and microk8s commands"
  microk8s() {
    echo "Bypassing microk8s, simulating success of"
    echo "microk8s $*"
    return 0
  }
fi

case ${OS_TYPE} in
Linux)
  LOCKSS_HOME=
  SHA256SUM=sha256sum
  LOCKSS_TIMEZONE=$(readlink -f /etc/localtime | sed -e 's/^.*zoneinfo\///')
  ;;
Darwin)
  LOCKSS_HOME=
  SHA256SUM=sha256sum
  LOCKSS_TIMEZONE=$(readlink /etc/localtime | sed -e 's/^.*zoneinfo\///')
  ;;
*)
  echo "${OS_TYPE} not supported"
  exit 1
  ;;
esac

LOCAL_IPADDR=$(guess_ip_address)

declare -i CONFIG_COUNT

echo "LOCKSS host configuration for ${OS_TYPE}."
echo "For more information see README"

if [ -r "${SYSTEM_CONF_FILE}" ]; then
  msg "${_DO} Setting defaults from existing config: ${SYSTEM_CONF_FILE}"
  read_config ${SYSTEM_CONF_FILE}
fi

#get the number of stacks
case "${1}" in
'') CONFIG_COUNT=1 ;;
[1-9]) CONFIG_COUNT="${1}" ;;
  *) echo "$(date) Invalid number of parallel stacks: ${1}" ; exit 1 ;;
esac

#build config file
echo "building config for ${CONFIG_COUNT} stacks on ${OS_TYPE} for user ${CONFIG_USER}..."
build_config_file ${SYSTEM_CONF_FILE} ${CONFIG_USER} ${CONFIG_COUNT}
echo "$(date) Run scripts/start-lockss to launch the LOCKSS stack 'lockss-stack'..."
